(define texmacs-user (current-module))
(define temp-module (current-module))
(define temp-value #f)

(define-macro (provide-public head . body)
  (if (or (and (symbol? head) (not (defined? head)))
	  (and (pair? head) (symbol? (car head)) (not (defined? (car head)))))
      `(define-public ,head ,@body)
      '(noop)))

(define-macro (inherit-modules . which-list)
  (define (module-exports which)
    (let* ((m (resolve-module which))
           (m-public (module-ref m '%module-public-interface)))
      (display "after resolve module") (newline)
      (display "m-public: ") (display m-public) (newline)
      (module-map (lambda (sym var) sym) m-public)))
      (set! temp-value (map module-exports which-list))
      (display "temp-value: ") (display temp-value) (newline)
  (let ((l (apply append (map module-exports which-list))))
    (display "export symbol list: ")
    (display l) (newline)
    `(begin
       (use-modules ,@which-list)
       (re-export ,@l))))

(define-macro (texmacs-module name . options)
  (define (transform action)
    (cond ((not (pair? action)) (noop))
	  ((equal? (car action) :use) (cons 'use-modules (cdr action)))
	  ((equal? (car action) :inherit) (cons 'inherit-modules (cdr action)))
	  ((equal? (car action) :export)
	   (display "Warning] The option :export is no longer supported\n")
	   (display "       ] Please use tm-define instead\n"))
	  (else '(noop))))
  (let ((l (map-in-order transform options)))
    (display "l: ") (display l) (newline)
	(set! l (cons `(module-use! (current-module) ,texmacs-user) l))
    (display "l: ") (display l) (newline)
    (display "loading ") (display name) (display "\n")
    `(begin
       (define-module ,name)
       ,@l)))

(display "module-public-interface: ")
(display (current-module))
(display (module-ref (current-module) '%module-public-interface))
(newline)
(display (module-map (lambda (sym var) sym) (module-ref (current-module) '%module-public-interface)))
(newline)