# modified from llvm-lit
# see https://github.com/llvm/llvm-project/blob/main/llvm/cmake/modules/AddLLVM.cmake

# Takes a list of path names in pathlist and a base directory, and returns
# a list of paths relative to the base directory in out_pathlist.
# Paths that are on a different drive than the basedir (on Windows) or that
# contain symlinks are returned absolute.
# Use with PSCM_LIT_PATH_FUNCTION below.
function(pscm_make_paths_relative out_pathlist basedir pathlist)
  # Passing ARG_PATH_VALUES as-is to execute_process() makes cmake strip
  # empty list entries. So escape the ;s in the list and do the splitting
  # ourselves. cmake has no relpath function, so use Python for that.
  string(REPLACE ";" "\\;" pathlist_escaped "${pathlist}")
  execute_process(COMMAND "${Python3_EXECUTABLE}" "-c" "\n
import os, sys\n
base = sys.argv[1]
def haslink(p):\n
    if not p or p == os.path.dirname(p): return False\n
    return os.path.islink(p) or haslink(os.path.dirname(p))\n
def relpath(p):\n
    if not p: return ''\n
    if os.path.splitdrive(p)[0] != os.path.splitdrive(base)[0]: return p\n
    if haslink(p) or haslink(base): return p\n
    return os.path.relpath(p, base)\n
if len(sys.argv) < 3: sys.exit(0)\n
sys.stdout.write(';'.join(relpath(p) for p in sys.argv[2].split(';')))"
    ${basedir}
    ${pathlist_escaped}
    OUTPUT_VARIABLE pathlist_relative
    ERROR_VARIABLE error
    RESULT_VARIABLE result)
  if (NOT result EQUAL 0)
    message(FATAL_ERROR "make_paths_relative() failed due to error '${result}', with stderr\n${error}")
  endif()
  set(${out_pathlist} "${pathlist_relative}" PARENT_SCOPE)
endfunction()


# Converts a file that's relative to the current python file to an absolute
# path. Since this uses __file__, it has to be emitted into python files that
# use it and can't be in a lit module. Use with make_paths_relative().
string(CONCAT PSCM_LIT_PATH_FUNCTION
  "# Allow generated file to be relocatable.\n"
  "import os\n"
  "import platform\n"
  "def path(p):\n"
  "    if not p: return ''\n"
  "    # Follows lit.util.abs_path_preserve_drive, which cannot be imported here.\n"
  "    if platform.system() == 'Windows':\n"
  "        return os.path.abspath(os.path.join(os.path.dirname(__file__), p))\n"
  "    else:\n"
  "        return os.path.realpath(os.path.join(os.path.dirname(__file__), p))\n"
  )




# This function provides an automatic way to 'configure'-like generate a file
# based on a set of common and custom variables, specifically targeting the
# variables needed for the 'lit.site.cfg' files. This function bundles the
# common variables that any Lit instance is likely to need, and custom
# variables can be passed in.
# The keyword PATHS is followed by a list of cmake variable names that are
# mentioned as `path("@varname@")` in the lit.cfg.py.in file. Variables in that
# list are treated as paths that are relative to the directory the generated
# lit.cfg.py file is in, and the `path()` function converts the relative
# path back to absolute form. This makes it possible to move a build directory
# containing lit.cfg.py files from one machine to another.
function(pscm_configure_lit_site_cfg site_in site_out)
cmake_parse_arguments(ARG "" "" "MAIN_CONFIG;PATHS" ${ARGN})

if ("${ARG_MAIN_CONFIG}" STREQUAL "")
  get_filename_component(INPUT_DIR ${site_in} DIRECTORY)
  set(ARG_MAIN_CONFIG "${INPUT_DIR}/lit.cfg")
endif()


set(HOST_OS ${CMAKE_SYSTEM_NAME})
set(HOST_ARCH ${CMAKE_SYSTEM_PROCESSOR})

set(HOST_CC "${CMAKE_C_COMPILER} ${CMAKE_C_COMPILER_ARG1}")
set(HOST_CXX "${CMAKE_CXX_COMPILER} ${CMAKE_CXX_COMPILER_ARG1}")
set(HOST_LDFLAGS "${CMAKE_EXE_LINKER_FLAGS}")

string(CONCAT LIT_SITE_CFG_IN_HEADER
  "# Autogenerated from ${site_in}\n# Do not edit!\n\n"
  "${PSCM_LIT_PATH_FUNCTION}"
  )

if (ARG_PATHS)
  # Walk ARG_PATHS and collect the current value of the variables in there.
  # list(APPEND) ignores empty elements exactly if the list is empty,
  # so start the list with a dummy element and drop it, to make sure that
  # even empty values make it into the values list.
  set(ARG_PATH_VALUES "dummy")
  foreach(path ${ARG_PATHS})
    list(APPEND ARG_PATH_VALUES "${${path}}")
  endforeach()
  list(REMOVE_AT ARG_PATH_VALUES 0)

  get_filename_component(OUTPUT_DIR ${site_out} DIRECTORY)
  pscm_make_paths_relative(
      ARG_PATH_VALUES_RELATIVE "${OUTPUT_DIR}" "${ARG_PATH_VALUES}")

  list(LENGTH ARG_PATHS len_paths)
  list(LENGTH ARG_PATH_VALUES len_path_values)
  list(LENGTH ARG_PATH_VALUES_RELATIVE len_path_value_rels)
  if ((NOT ${len_paths} EQUAL ${len_path_values}) OR
      (NOT ${len_paths} EQUAL ${len_path_value_rels}))
    message(SEND_ERROR "PATHS lengths got confused")
  endif()

  # Transform variables mentioned in ARG_PATHS to relative paths for
  # the configure_file() call. Variables are copied to subscopeds by cmake,
  # so this only modifies the local copy of the variables.
  math(EXPR arg_path_limit "${len_paths} - 1")
  foreach(i RANGE ${arg_path_limit})
    list(GET ARG_PATHS ${i} val1)
    list(GET ARG_PATH_VALUES_RELATIVE ${i} val2)
    set(${val1} ${val2})
  endforeach()
endif()

configure_file(${site_in} ${site_out} @ONLY)

if (EXISTS "${ARG_MAIN_CONFIG}")
  # Remember main config / generated site config for llvm-lit.in.
  get_property(PSCM_LIT_CONFIG_FILES GLOBAL PROPERTY PSCM_LIT_CONFIG_FILES)
  list(APPEND PSCM_LIT_CONFIG_FILES "${ARG_MAIN_CONFIG}" "${site_out}")
  set_property(GLOBAL PROPERTY PSCM_LIT_CONFIG_FILES ${PSCM_LIT_CONFIG_FILES})
endif()
endfunction()


function(get_pscm_lit_path base_dir file_name)
  cmake_parse_arguments(ARG "ALLOW_EXTERNAL" "" "" ${ARGN})
  set(lit_file_name "pscm-lit")
  if (CMAKE_HOST_WIN32 AND NOT CYGWIN)
    # llvm-lit needs suffix.py for multiprocess to find a main module.
    set(lit_file_name "${lit_file_name}.py")
  endif ()
  set(${file_name} ${lit_file_name} PARENT_SCOPE)

  get_property(PSCM_LIT_BASE_DIR GLOBAL PROPERTY PSCM_LIT_BASE_DIR)
  if (NOT "${PSCM_LIT_BASE_DIR}" STREQUAL "")
    set(${base_dir} ${PSCM_LIT_BASE_DIR} PARENT_SCOPE)
  endif()

  set(PSCM_LIT_BASE_DIR "${PSCM_BINARY_DIR}/bin")

  # Cache this so we don't have to do it again and have subsequent calls
  # potentially disagree on the value.
  set_property(GLOBAL PROPERTY PSCM_LIT_BASE_DIR ${PSCM_LIT_BASE_DIR})
  set(${base_dir} ${PSCM_LIT_BASE_DIR} PARENT_SCOPE)
endfunction()


# A raw function to create a lit target. This is used to implement the testuite
# management functions.
function(pscm_add_lit_target target comment)
  cmake_parse_arguments(ARG "" "" "PARAMS;DEPENDS;ARGS" ${ARGN})
  set(LIT_ARGS "${ARG_ARGS} ${PSCM_LIT_ARGS}")
  separate_arguments(LIT_ARGS)
  if (NOT CMAKE_CFG_INTDIR STREQUAL ".")
    list(APPEND LIT_ARGS --param build_mode=${CMAKE_CFG_INTDIR})
  endif ()

  # Get the path to the lit to *run* tests with.  This can be overriden by
  # the user by specifying -DLLVM_EXTERNAL_LIT=<path-to-lit.py>
  get_pscm_lit_path(
    lit_base_dir
    lit_file_name
    ALLOW_EXTERNAL
    )

  set(LIT_COMMAND "${Python3_EXECUTABLE};${lit_base_dir}/${lit_file_name}")
  list(APPEND LIT_COMMAND ${LIT_ARGS})
  # Add -v (verbose) flag to show detailed error output on failure, similar to LLVM's check-clang
  # This ensures error logs are displayed when tests fail
  list(APPEND LIT_COMMAND -v)
  foreach(param ${ARG_PARAMS})
    list(APPEND LIT_COMMAND --param ${param})
  endforeach()
  if (ARG_UNPARSED_ARGUMENTS)
    add_custom_target(${target}
      COMMAND ${LIT_COMMAND} ${ARG_UNPARSED_ARGUMENTS}
      COMMENT "${comment}"
      USES_TERMINAL
      )
  else()
    add_custom_target(${target}
      COMMAND ${CMAKE_COMMAND} -E echo "${target} does nothing, no tools built.")
    message(STATUS "${target} does nothing.")
  endif()

  if (ARG_DEPENDS)
    add_dependencies(${target} ${ARG_DEPENDS})
  endif()

  # Tests should be excluded from "Build Solution".
  set_target_properties(${target} PROPERTIES EXCLUDE_FROM_DEFAULT_BUILD ON)
  set_target_properties(${target} PROPERTIES XCODE_GENERATE_SCHEME ON)
endfunction()



# A function to add a set of lit test suites to be driven through 'check-*' targets.
function(pscm_add_lit_testsuite target comment)
  cmake_parse_arguments(ARG "EXCLUDE_FROM_CHECK_ALL" "" "PARAMS;DEPENDS;ARGS" ${ARGN})

  # EXCLUDE_FROM_ALL excludes the test ${target} out of check-all.
  if(NOT ARG_EXCLUDE_FROM_CHECK_ALL)
    get_property(gather_names GLOBAL PROPERTY LLVM_LIT_UMBRELLAS)
    foreach(name ${gather_names})
    # Register the testsuites, params and depends for the umbrella check rule.
      set_property(GLOBAL APPEND PROPERTY LLVM_${name}_LIT_TESTSUITES ${ARG_UNPARSED_ARGUMENTS})
      set_property(GLOBAL APPEND PROPERTY LLVM_${name}_LIT_PARAMS ${ARG_PARAMS})
      set_property(GLOBAL APPEND PROPERTY LLVM_${name}_LIT_DEPENDS ${ARG_DEPENDS})
      set_property(GLOBAL APPEND PROPERTY LLVM_${name}_LIT_EXTRA_ARGS ${ARG_ARGS})
    endforeach()
  endif()

  # Produce a specific suffixed check rule.
  pscm_add_lit_target(${target} ${comment}
    ${ARG_UNPARSED_ARGUMENTS}
    PARAMS ${ARG_PARAMS}
    DEPENDS ${ARG_DEPENDS}
    ARGS ${ARG_ARGS}
    )
endfunction()

